---
title: MCP Server
description: Giving your AI hands
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Skills teach your AI how to write Algorand code. The MCP server lets it actually do things: deploy contracts, call methods, create accounts, manage assets.

MCP (Model Context Protocol) is a standard for giving AI tools access to external systems. VibeKit's MCP server exposes 44 blockchain operations that your AI can call directly.

## How it works

The server starts automatically when you open a VibeKit-configured project in Claude Code or OpenCode. Your AI sees the available tools and uses them as needed.

No manual orchestration. Ask your AI to deploy a contract, and it builds the transaction, requests a signature from your account provider, and submits it to the network.

## Two servers

VibeKit configures two MCP servers:

- **vibekit-mcp** — The 44 blockchain operations below: deploying contracts, calling methods, managing accounts and assets, querying state.
- **kappa** — Searches official Algorand documentation. When your AI needs current information about Algorand APIs, SDKs, or concepts, it queries the docs directly.

Both start automatically with your AI tool.

:::note[Additional MPCs]
VibeKit's MCP server is purpose-built for development workflows and integrates seamlessly with the secure account providers. For broader ecosystem interactions, the community-maintained [algorand-mcp](https://github.com/GoPlausible/algorand-mcp) offers additional capabilities.
:::

## What the AI can do

| Category      | Examples                                  |
| ------------- | ----------------------------------------- |
| **Contracts** | Deploy, call methods, delete apps         |
| **State**     | Read global, local, and box storage       |
| **Accounts**  | Create, fund, check balances              |
| **Assets**    | Create ASAs, transfer, opt-in             |
| **Network**   | Switch between localnet/testnet/mainnet   |
| **Search**    | Query indexer, search GitHub for examples |

## Tool reference

<Tabs>
  <TabItem label="Accounts">
    | Tool | Description |
    |------|-------------|
    | `list_accounts` | List all accounts with balances |
    | `get_account_info` | Get detailed account information |
    | `create_account` | Create a new account |
    | `switch_account` | Switch the active account |
    | `get_active_account` | Get the currently active account |
    | `send_payment` | Send ALGO payment |
    | `fund_account` | Fund an account from the dispenser |
  </TabItem>
  <TabItem label="Assets">
    | Tool | Description |
    |------|-------------|
    | `create_asset` | Create a new ASA |
    | `get_asset_info` | Get asset details |
    | `asset_opt_in` | Opt into an asset |
    | `asset_transfer` | Transfer assets |
    | `asset_opt_out` | Opt out of an asset |
    | `asset_freeze` | Freeze/unfreeze asset holdings |
    | `asset_config` | Reconfigure an asset |
    | `asset_destroy` | Destroy an asset |
  </TabItem>
  <TabItem label="Contracts">
    | Tool | Description |
    |------|-------------|
    | `app_deploy` | Deploy a smart contract |
    | `app_call` | Call a contract method |
    | `app_get_info` | Get application info |
    | `app_list_methods` | List available methods |
    | `app_opt_in` | Opt into an application |
    | `app_close_out` | Close out of an application |
    | `app_delete` | Delete an application |
  </TabItem>
  <TabItem label="State">
    | Tool | Description |
    |------|-------------|
    | `read_global_state` | Read application global state |
    | `read_local_state` | Read account local state |
    | `read_box` | Read box storage |
  </TabItem>
  <TabItem label="Indexer">
    | Tool | Description |
    |------|-------------|
    | `indexer_lookup_transaction` | Look up a transaction by ID |
    | `indexer_search_transactions` | Search transactions with filters |
    | `indexer_lookup_application` | Look up application details |
    | `indexer_lookup_application_logs` | Get application log messages |
    | `indexer_lookup_asset` | Look up asset details |
  </TabItem>
  <TabItem label="Network">
    | Tool | Description |
    |------|-------------|
    | `switch_network` | Switch between localnet/testnet/mainnet |
    | `get_network` | Get current network configuration |
  </TabItem>
  <TabItem label="GitHub">
    | Tool | Description |
    |------|-------------|
    | `github_get_file_contents` | Get file contents from a repository |
    | `github_search_code` | Search code across repositories |
    | `github_search_repositories` | Search for repositories |
  </TabItem>
  <TabItem label="Utilities">
    | Tool | Description |
    |------|-------------|
    | `get_provider` | Get current account provider |
    | `send_atomic_group` | Send an atomic transaction group |
    | `validate_address` | Validate an Algorand address |
    | `get_application_address` | Get address for an application |
    | `algo_to_microalgo` | Convert ALGO to microALGO |
    | `microalgo_to_algo` | Convert microALGO to ALGO |
    | `calculate_min_balance` | Calculate minimum balance requirement |
  </TabItem>
</Tabs>

## Running manually

The server starts automatically with your AI tool, but you can also run it directly:

```bash
vibekit mcp
```

This is useful for debugging or connecting to tools that don't auto-detect MCP servers.

## Configuration

The MCP server is configured during `vibekit init`. It stores connection settings in your project's `.mcp.json` or your AI tool's config directory.

To reconfigure:

```bash
vibekit init
```

## Network switching

Your AI can switch networks on the fly:

- **localnet** — AlgoKit LocalNet, for development
- **testnet** — Algorand TestNet, for integration testing
- **mainnet** — Algorand MainNet, for production

Accounts in your configured provider (Keyring or Vault) work on any network. KMD is only used for dispensers on localnet.

## What the AI can't do

The MCP server is designed with limits:

- **No key access.** It can request signatures, not export keys.
- **No arbitrary code execution.** It can only call the defined tools.
- **No network bypass.** All transactions go through standard Algorand nodes.

These aren't bugs. They're the security model. See [Account Providers](/features/account-providers) for how signing works.
